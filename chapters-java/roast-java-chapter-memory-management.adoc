== MEMORY MANAGEMENT

* What is stack?
* What is heap?
* How is memory allocated and de-allocated in stack, during its lifecycle?
* When does the stack memory gets released?
* When does the heap memory gets released?
* Why memory allocation in stack is faster as compared to heap?
* Why do you need to apply synchronization to the heap memory and not to the stack memory?
* How can you differentiate between stack memory and heap memory?
* What exception do you get when stack memory is exhausted?
* What exception do you get when heap memory is exhausted?
* What is “OutofMemoryException?” How can we handle it?
* Do you need to explicitly release the objects on stack?
* What is heap fragmentation?
* Why does heap fragmentation happens?
* Who has the responsibility to reduce heap fragmentation?
* How can you control heap fragmentation?
* What happens when there is very high level of heap fragmentation?
* Why does heap fragmentation slows down the application?
* Can you increase the heap memory of JVM?
* What is serialization and de-serialization?
* Which interface needs to be implemented by the type that wants to support serialization?
* How can you prevent a member from serialization?
* Which classes in Java are used to serialize and de-serialize objects?
* What is Garbage Collection?
* Explain Garbage Collection cycle?
* Why Garbage Collection is considered expensive process?
* Why after Garbage Collection cycle, usually the performance of the application improves?
* How does Garbage Collection prevents OutOfMemoryException?
* Which type of thread is used for Garbage Collection: Daemon or user thread?
* What is memory fragmentation?
* Why does application seems to slow down when Garbage Collection happens?
* Can you explicitly request a Garbage Collection?
* Which method can you call to request Garbage Collection?
* Does Garbage Collection always happen when requested?
* How is Heap memory divided?
* Explain different generations of heap memory? How objects are moved across generations?
* How is garbage collection cycle triggered?
* What are Eden and Survivor spaces in New Generation memory?
* When does the objects in Eden moves to Survivor space?
* What is Metaspace?
* What type of objects are stored in Metaspace?
* Why Metaspace has virtually unlimited space?
* In which generation does the Garbage Collection cycle runs slowest? Why?
* Which generation is more frequently garbage collected?
* What is weak reference?
* What is soft reference?
* What is Phantom Reference?
* What are the reference types that gets collected by the Garbage Collector, even when the objects of their types are still in use?
* What is the difference between soft reference and weak reference?
* What is the typical usage of weak reference?
* What is the typical usage of soft reference?
* What is the typical usage of Phantom reference?
* Which is collected first: soft reference or weak reference?
* How JVM executes class?
* What is Just-in-time(JIT) compilation in Java? What is the importance of JIT?
* How JIT works internally to choose methods to compile?
* Can we have different versions of JIT than the Java version?
* Can you disable JIT?
* If you disable JIT, what consequences will you face?
* What is the difference between JDK, JRE, and JVM?
* What is the use of the printstackTrace() method?
* Describe the different types of memory areas generated by JVM
* What is Method Area and where it belongs?
* Where is Java String pool located?
* When are static variables loaded in memory?
* What happens when we import any package or class? what if the same import is repeated in multiple classes? Will the JVM load the package or class twice at runtime?
* When is the finalize() method called in Java?
* When the class is loaded by classloader?
* What are different ways to create String object? Explain.
* When memory is allocated for static variables in java?
* Where does static method, variables are stored in Java?

.What is memory leak?
[%collapsible]
====
Garbage collector handles memory management, but when garbage collector is not able to free any object that is not used by the application but it still holds the reference to it is called memory leak.
In other words, when the program/application allocates memory for the object and later when object is no longer needed, instead of marking the reference as null, application holds the indirect reference to that object in such a way that garbage collector cannot free that object is called memory leak. slowly, application memory starts growing and ultimately result in OutOfMemoryError.
====

.What happens when Garbage Collector(GC) runs? what does it mean by "stop-the-world"?
[%collapsible]
====
When GC thread runs, other threads are stopped for that duration, so application waits for that duration.
Irrespective of GC need to run in Old generation or New Generation, all the events of GC run will pause application threads until GC run completes.
====

.What goes in Heap and Stack?
[%collapsible]
====
Heap and Stack both are the part of RAM. So there is a separate space in RAM for stack and heap.
* `Local variables/references`: All the local variables (primitive type) of the method and the method call itself goes to Stack.
* `Objects`: when an object is created using new operator, the actual space for that object is allocated in heap but the reference to that space(object) is created in stack.
====


.What is the scope of Heap and Stack?
[%collapsible]
====
The stack is associated for a thread, so when the thread is done the stack is reclaimed. The heap is typically allocated at application startup by the runtime, and is reclaimed when the application (technically process) exits.
====

.Which is faster Stack or Heap? Why?
[%collapsible]
====
Stack is faster in many terms than Heap though they both are part of RAM. +
For Stack, in terms of deletion, it just needs to move the pointers in LIFO Manner, whereas for Heap, it has to do checks for live references along with that deletion creates fragmentation issues where if memory is freed in non continuous manner, then it has to do compaction (Memory compaction is the process of moving allocated objects together and leaving empty space together.) +

Heap is shared across Threads, so allocation/deallocation of memory needs to be synchronized for Heaps, but for Stack, memory is private to Stack. this is also the reason Stack is faster than Heap. +

Stack is generally accessed more frequently so for that purpose data of Stack is cached and that is also the reason it is faster than Heap. +

The heap is a portion on RAM which is not managed automatically, and is not as tightly managed by the CPU. It is a just a block of memory and need to be managed by user. To allocate memory on the heap, you must use new keyword. we are responsible for deallocation of unused memory once we no longer require it, failing which can cause memory leaks.
====

.How you fine tune Heap size?
[%collapsible]
====
-Xms (example: -Xms64m or -Xms64M) +
Sets the initial size of the Java heap. +
+
-Xmx (example: -Xmx1g or -Xmx1G) +
Sets the maximum size to which the Java heap can grow. +

-Xmn (example: -Xmn512, -Xmn512m, -Xmn512k) +
Sets the initial Java heap size for the Young generation(Eden generation). +
+
-Xss (example: -Xss512, -Xss512m, -Xss512k) +
Sets the maximum stack size of each thread. +
This option allows to fine tune max size allocated to each thread to store local variable, partial results and method calling information. +
When the method is doing heavy operation with lots of variables, method calls and if you are encountering  StackOverflowError, you can fine tune stack size by using this flag. +
+
-Xnoclassgc +
Disables garbage collection (GC) of classes. When you specify -Xnoclassgc at startup, the class objects in the application will be left untouched during GC and will always be considered live. This can result in more memory being permanently occupied which, if not used carefully, will throw an out of memory exception.
====

.When you encounter StackOverflowError and OutOfMemoryError?
[%collapsible]
====
StackOverflowError : +
Stack is used in Java for method execution, for every method call, a block of memory is created in the stack. The data related to method like parameters, local variables or references to objects are stored in this block. +

When the method finishes its execution, this block is removed from the stack along with data stored in it. If a method keep calling other method recursively without returning back then at one point Stack will be full and there would not be any space left for allocating new stack block at that time you will encounter StackOverflowError. +

OutOfMemoryError: +
When there is no space left for creating new objects on Heap memory, java.lang.OutOfMemoryError  is thrown. +
OutOfMemoryError is encountered in two scenarios:  +
1. java.lang.OutOfMemoryError: Java heap space Issue  +
2. java.lang.OutOfMemoryError: PermGen space Issue  +
====

.How Garbage collection works, What is Mark and Sweep algorithm for garbage collection?
[%collapsible]
====
In Java, GC handles memory management, so it is GC's job to remove the object and free up the heap space when it is no longer referenced.
For removing the object, it first need to scan all the objects present, whether there exist any active references to the object or not, and remove the object those are not referenced from anywhere.
====

.Does GC guarantees that a program will not run OutOfMemory?
[%collapsible]
====
GC does not guarantee that a program will not run out of memory. It is possible that Program create objects faster as compare to GC cleaning the unreferenced objects. Also, it is possible that application creates lots of heavy object and holding the references to those object in this case GC can't help and may cause OutOfMemory error.
====

.How many Class loaders are present in JVM?
[%collapsible]
====
First of all what Class loader does is load the .class files from physical location to JVM's memory and stores information such as class names, parent class, methods, constructors etc. +

There are mainly 3 class loaders present in JVM, +
Bootstrap ClassLoader: This classloader prime responsibility is to load internal core java classes present in the rt.jar and other classes present in the java.lang.* package. This class loader is shipped with every JVM and is written in native language. This class loader has no parent classloader. +
+
Extension ClassLoader: This classloader responsibility is to load classes from jre\lib\ext folder. +
The parent of this class loader is Bootstrap classloader. Java extensions are also referred to as optional packages. +
+
Application or System ClassLoader: The parent of this class loader is Extension classloader and is responsible for loading the classes from the system classpath(generally classes folder). It internally uses the ‘CLASSPATH‘ environment variable and is written in Java language. +
+
Note: Class is loaded into memory only once even if you try to load multiple times.
====


.When you get NoClassDefFoundError?
[%collapsible]
====
[source,java]
----
class Student { }
public class MainApp {
    public static void main(String[] args){
        Student stud = new Student();
    }

> javac MainApp.java
Above command will generate 2 classes MainApp.class and Student.class
Delete Student.class file
> java MainApp
This will throw NoClassDefFoundError
----
====

.When you get ClassNotFoundException?
[%collapsible]
====
It is an runtime exception and is caused when application tries to explicitly load any class using Class.forName("path of class") and if the class is not available at the mentioned Path then it throws ClassNotFoundException.
====


.How JVM Heap memory blocks is divided?
[%collapsible]
====
* Till Java 7 +
Eden space, S0, S1 = Young Generation
S0, S1 = Survivor Space
Old Memory = Old Generation = Tenured Memory
Perm = Permanent Generation

* Java 8 +
PermGen space which was part of Heap is removed in Java8 and is now called Metaspace.
====



=== PRACTICAL TASKS: Memory Management

.Stack vs Heap: task 01
[%collapsible]
====
[source,java]
----
class Test {
    public static void main(String args[]) {
       Student s1 = new Student(10, "Jason", new Address("V5H3U7"));
    }
}

class Student {
    String rollNumber;
    String name;
    Address address;
}

class Address {
    String zipcode;
}
----
====

[%collapsible]
====
.SOLUTION
----
#main
STACK                   HEAP
                        Address{zip code = "V5H3U7"}
                            |
s1 ----------------> Student{ rollNumber = 10, name="Jason", address}
----
====


.Stack vs Heap: task 02
[%collapsible]
====
[source,java]
----
class Test {
    public static void main(String args[]) {
       createPoint();
    }

    public void createPoint() {
        int x = 6;
        int y = 8;
        Point point = new Point(x, y);
    }
}
class Point {
    int x;
    int y;
    Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
----
====

[%collapsible]
====
.SOLUTION
----
STACK                   HEAP
#createPoint
int x = 6;
int y = 8;
point ----------------> Point{ x = 6, y = 8}
----
====


.Stack vs Heap: task 03
[%collapsible]
====
[source,java]
----
public class Test {

    public static void main(String[] args) { // L01
        int i = 1; // L02
        Object obj = new Object(); // L03
        Memory mem = new Memory(); // L04
        mem.foo(obj); // L05
    } // L10

    private void foo(Object param) { // L06
        String str = param.toString(); // L07
        System.out.println(str); // L08
    } // L09

}
----
====

[%collapsible]
====
.SOLUTION
----
STACK                   HEAP
#foo
str   ----------------> StringPool#Object
param ----------------> Object

#main
mem -----------------> Object
obj -----------------> Object
int i = 1;
----
====


.Stack vs Heap: task 04
[%collapsible]
====
[source,java]
----
public class Test {

    public static void main(String[] args) {
        int i = 1;
        int j = 2;
        Test ref =  new Test();
        ref.foo(i);
    }

    private void foo(int param) {
        int x = 3;
        Object y = new Object();
        System.out.println(param);
    }
}
----
====

.Difference Between Stack and Heap Memory
[options="header"]
|=======================
|Parameter | Stack Memory | Heap Space
|Application | ? |  ?
|Creation | ? |  ?
|Ordering | ? |  ?
|Order of allocation | ? |  ?
|Flexibility | ? |  ?
|Efficiency | ? |  ?
|Memory Size | ? |  ?
|Java Options Used | ? |  ?
|Visibility or Scope | ? |  ?
|Generation of Space | ? |  ?
|Distribution | ? |  ?
|Exception Throws | ? |  ?
|Allocation/ Deallocation | ? |  ?
|Cost | ? |  ?
|Implementation | ? |  ?
|Thread-Safety | ? |  ?
|=======================
[%collapsible]
====

|=======================
|Parameter | Stack Memory | Heap Space
|Application | It stores items that have a very short life such as methods, variables, and reference variables of the objects. |  It stores objects and Java Runtime Environment (JRE) classes.
|Creation | It is created when a thread creates.The stack memory is a physical space (in RAM) allocated to each thread at run time.  |  It is created when the JVM starts up and used by the application as long as the application runs.
|Ordering | It follows the LIFO order. |  	It does not follow any order because it is a dynamic memory allocation and does not have any fixed pattern for allocation and deallocation of memory blocks.
|Order of allocation | Memory allocation is continuous. |  Memory allocated in random order.
|Flexibility | It is not flexible because we cannot alter the allocated memory. |  It is flexible because we can alter the allocated memory.
|Efficiency | It has faster access, allocation, and deallocation. |  It has slower access, allocation, and deallocation.
|Memory Size | It is smaller in size. |  It is larger in size.
|Java Options Used | We can increase the stack size by using the JVM option -Xss. |  We can increase or decrease the heap memory size by using the -Xmx and -Xms JVM options.
|Visibility or Scope | The variables are visible only to the owner thread. |  It is visible to all threads.
|Generation of Space | When a thread is created, the operating system automatically allocates the stack. |  To create the heap space for the application, the language first calls the operating system at run time.
|Distribution | Separate stack is created for each object. |  It is shared among all the threads.
|Exception Throws | JVM throws the java.lang.StackOverFlowError if the stack size is greater than the limit. To avoid this error, increase the stack size. |  VM throws the java.lang.OutOfMemoryError if the JVM is unable to create a new native method.
|Allocation/ Deallocation | It is done automatically by the compiler. |  It is done manually by the programmer.
|Cost | Its cost is less. |  Its cost is more in comparison to stack.
|Implementation | Its implementation is hard. | Its implementation is easy.
|Thread-Safety | It is thread-safe because each thread has its own stack. |  It is not thread-safe, so properly synchronization of code is required.
|=======================
====